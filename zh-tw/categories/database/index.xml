<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Database on Shawn&#39;s Note</title>
        <link>http://shawn1251.github.io/zh-tw/categories/database/</link>
        <description>Recent content in Database on Shawn&#39;s Note</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-tw</language>
        <lastBuildDate>Wed, 31 Jul 2024 00:00:00 +0800</lastBuildDate><atom:link href="http://shawn1251.github.io/zh-tw/categories/database/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Distributed Database System Lecture Note</title>
        <link>http://shawn1251.github.io/zh-tw/post/distributed-database-lecture-note/</link>
        <pubDate>Wed, 31 Jul 2024 00:00:00 +0800</pubDate>
        
        <guid>http://shawn1251.github.io/zh-tw/post/distributed-database-lecture-note/</guid>
        <description>&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;./file/Distributed%20Database%20System.pdf&#34; &gt;Mind Map&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Instructor’s name: Ali Safari &lt;br&gt;
Textbook: Principles of Distributed Database Systems, 4th edition, M. Tamer Özsu and Patrick Valduriez,
Springer, 2020, ISBN 978-3-030-26252-5&lt;/p&gt;
&lt;h2 id=&#34;distributed-and-parallel-database-design&#34;&gt;Distributed and Parallel Database Design&lt;/h2&gt;
&lt;h3 id=&#34;fragmentation&#34;&gt;fragmentation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;correctness&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;completness&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;each data in relation can also be found after fragmentation&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;reconstruction&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;by JOIN, the fragment can recovery to the original relation&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;disjointness&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;data in one fragment should not also be in other fragment&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;type&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;horizontal fragmentation (HF&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;primary horizontal (PHF&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;key points&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;simple prdicate&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;predicate: key + operator + value&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;eg. salary &amp;gt; 1000&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;minterm predicate&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;all possible combination of predicate&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;eg. loc = &amp;ldquo;France&amp;rdquo; ^ salary &amp;gt; 1000&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;minterm selectivities, sel(mi)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the percentage of records that minterm selected&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;access frequency, acc(qi)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;how many times the same query asked by different user&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cardinality, card(R)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;number of rows&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;COM_MIN algorithm&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;input: a relation R, a set of simple predicates Pr&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;output: a &amp;ldquo;complete&amp;rdquo;, &amp;ldquo;minimal&amp;rdquo; set of simple predicates Pr&#39;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PHORIZONTAL Algorithm&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;input: a relation R, a set of predicates Pr&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;output: a set of minterm predicates M according to which relation R is to be fragmented&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;derived horizontal (DHF&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Based on the fragments created by PHF, apply similar fragmentation to other related relations.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;eg. after PHF, we divide &amp;ldquo;PAY&amp;rdquo; to 2 fragments. There is also a relation &amp;ldquo;EMP&amp;rdquo; related with &amp;ldquo;PAY&amp;rdquo;. We can also divide &amp;ldquo;EMP&amp;rdquo; by the same rule&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;vertical fragmentation (VF&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;affinity matrix&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;calculate by access frequency matrix and usage matrix&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;bond energy algorithm (BEA&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;input: the AA matrix (attribute affinity)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;output: the CA matrix(clustered affinity matrix)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;by changing the order what&amp;rsquo;s the most contribution I can get?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;find the best order for columns&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hybrid fragmentation&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;apply both horizontal and vertical&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;reconstruction&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;vertical: join&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;horizontal: union&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;data-distribution&#34;&gt;data distribution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;allocation alternatives&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;non-replicated&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;each fragment resides at only one site&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;replicated&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;fully replicated&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;each fragment at each site&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;partially replicated&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;each fragment at some of the sites&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;if read-only queries &amp;raquo; update queries, replication is good&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;fragment allocation&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;problem: fragments, network, application&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;find the optimal distribution&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;minimal cost&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;performance&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;constraint&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;response time&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;storage&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;processing&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;decision variable&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Xij. 1 if fragment i store in at Site j. 0 otherwise&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;both FAP and DAP are NP-complete&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;heuristic based on. about finding the best combination&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;combined-approach&#34;&gt;combined approach&lt;/h3&gt;
&lt;h2 id=&#34;transaction&#34;&gt;transaction&lt;/h2&gt;
&lt;h3 id=&#34;all-operations-as-one-unit-whole-or-nothing&#34;&gt;all operations as one unit. whole or nothing&lt;/h3&gt;
&lt;h3 id=&#34;acid&#34;&gt;ACID&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Atomicity&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;one unit&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Consistency&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Isolation&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Durability&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;concurrent-execution&#34;&gt;concurrent execution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;increase processor and disk utilization (I/O no need CPU)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;reduced average response time&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;important: multi tasks run in the but the result should be the same as serial running&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;validation&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;except read - read, all the others are conflict&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;try to move commands to see if they can be restored to the serial running format&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;if the commands are conflict, it should not be moved&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;serializability&#34;&gt;serializability&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;view serializability&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;not strict&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the initial, update, final result should be the same as serial schedule&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;check a schedule is serializable is NP-Complete problem&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;conflict serializability&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;more strict&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;conflict serializable is the sub set of serializable&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;there is no any conflict between transactions(R/W, W/W)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;test method&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;swap non-conflicting instruction&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;If a schedule S can be transformed into a schedule S’ by a series of swaps of non-conflicting instructions, we say that S and S’ are conflict equivalent&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a schedule S is conflict serializable if it is conflict equivalent to a serial schedule&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;precedence graph&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;transaction =&amp;gt; node&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;conficts =&amp;gt; edge&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;if graph has cycle, means not serializable&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;can do topological sorting&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;failure&#34;&gt;failure&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;rollbacks&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;cascading rollback&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 transaction failure, all the other transactions rollback&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;recoverable schedule&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ensure data consistency&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;reading transaction can read data which not commit yet, but cannot commit before the writing transaction&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cascadeless schedules&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;enhace recoverable schedule&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;is the subset of recoverable&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;transaction can only read data which is commited&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the schedule which try to avoid cascading rollbacks&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;concurrency-control&#34;&gt;concurrency control&lt;/h2&gt;
&lt;h3 id=&#34;concept&#34;&gt;concept&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;the mechanism provided by the db system&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;serial schedule is recoverable and cascadeless&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;have to trade off between serial schedule and concurrent schedule&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ensure schedule is conflict or view serializable&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ensure the schedule is  rcoverable and preferably cascadeless&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;to achieve these purpose, it needs a &amp;ldquo;protocol&amp;rdquo; to assure serializability&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;protocols&#34;&gt;protocols&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;lock-based protocols&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;exclusive (X) mode&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;cannot add any other lock&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;only one transaction can R/W data&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;shared (S) mode&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;can add more shared lock&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;multiple read transaction can read the data at the same time&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;two-phase locking protocol&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;grow-lockpoint-shrink&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;grow&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;the transaction acquire all the lock before access without release&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;can convert lock-S to lock-X (upgrade)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;shrink&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;start to releasing locks, cannot acquire any new lock&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;can convert lock-X to lock-S (downgrade)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;type&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;strict two-phase locking&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;keep all the X-lock till commit/abort&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;rigorous two-phase locking&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;keep all the locks till commit/abort&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ensure conflict-serializable&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cannot avoid deadlock&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;startegy&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;read:
if lock:
read()
else:
if lock-X:
wait()
grant lock-S
read()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;write:
if lock-X:
write()
else:
if other locks:
wait()
if lock-S:
upgrade to lock-X
else:
grant lock-X
write()&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;lock table&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;maintain by lock manager&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;lock table, record the type of lock granted or requested&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;like hash table&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;validate before grant new lock&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if there are multiple locks, the last one can only be lock-X&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Graph based protocol&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;alternative to two phase locking&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tree protocol&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Only exclusive locks are allowed&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;once unlock, cannot relock&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;conflict serializable&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;not gurantee recoverability&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;no deadlock&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;deadlock-prevention-strategies&#34;&gt;deadlock prevention strategies&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;wait-die&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;older may wait for younger release&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;younger never wait, rolled back instead&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wound-wait&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;older can force rollback younger&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;younger may wait for older&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;fewer rollback than wait-die&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;timeout-based schemes&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;deadlock-detection&#34;&gt;deadlock detection&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;wait-for graph&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Ti -&amp;gt; Tj: Ti is waiting for a lock held by Tj&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;deadlock if there is a cycle&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;deadlock-recovery&#34;&gt;deadlock recovery&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;total rollback&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;partial rollback&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;difficult&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;multiple-granularity&#34;&gt;multiple granularity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;can be represented as a tree&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;locks a node, also locks all the children node&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fine granularity: high concurrency, lower in tree&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Coarse granularity: low concurrency, higher in tree&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;intention lock modes&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;3 more lock mode than S, X&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;intention-shared (IS)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;same as S, but locking at a lower level&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;intention-exclusive (IX)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;shared and intention-exclusive (SIX)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;allow a higher level node to be locked without having to check all descendent nodes&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the compatibility matrix for all lock modes&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;timestamp-based-protocols&#34;&gt;Timestamp-based protocols&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;timestamp order = serializability order&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Timestamp-ordering protocol&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;WTS(Q) (W-timestamp): the largest timestamp of any transaction that executed &amp;ldquo;write(Q)&amp;rdquo;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RTS(Q) (R-timestamp): the largest timestamp of any transaction that executed &amp;ldquo;read(Q)&amp;rdquo;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;algorithm&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Ti = Read(Q)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;if TS(Ti) &amp;lt; WTS(Q), Reject
(Ti needs the value that was already overwritten)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;if TS(Ti) &amp;gt;= WTS(Q), execute, RTS(Q) update to max(RTS(Q), TS(Ti))
(Read after latest update is accepted)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ti = Write(Q)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;if TS(Ti) &amp;lt; RTS(Q), Reject
(Ti produce a value that was  needed previously)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;if TS(Ti) &amp;lt; WTS(Q), Reject
(Ti try to write an obsolete value)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;else, WTS(Q) update to TS(Ti)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;transaction-processing-2&#34;&gt;transaction processing-2&lt;/h2&gt;
&lt;h3 id=&#34;distributed-tm-architecture&#34;&gt;Distributed TM Architecture&lt;/h3&gt;
&lt;h3 id=&#34;serializability-1&#34;&gt;serializability&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;the condition that global transaction is serializable&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;each local history should be serializable&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;two conflicting operations should be in the same relative order in all of the local histories where they appear together&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;concurrency-control-algorithms&#34;&gt;concurrency control algorithms&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Pessimistic&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Two-Phase Locking-based (2PL)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;centralized 2PL&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;only one 2PL scheduler in the distributed system&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;lock requests are issued to the central scheduler&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pros: Simple&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cons: reliability, bottle neck&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;distributed 2PL&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;deadlock&#34;&gt;Deadlock&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;locking-based algorithm may cause deadlocks&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TO based algorithm that involve waiting may cause deadlocks&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wait-for graph&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Ti waits for Tj&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ti &amp;ndash;&amp;gt; Tj&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;query-processing&#34;&gt;Query Processing&lt;/h2&gt;
&lt;h3 id=&#34;for-one-query-there-may-be-several-strategies&#34;&gt;for one query, there may be several strategies&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;optimization: calculate the cost, then choose the lowest one&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;access cost&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;transfer cost&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;example&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;problem&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cost of Alternatives&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;complexity-of-relational-operations&#34;&gt;Complexity of relational operations&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Select
Project&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Project (eliminate duplicate)
Group&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;O(n * log n)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sorting + check the array sequentially&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Join
Semi-Join
Division
Set&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;O(n * log n)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cartesian Product&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;O(n^2)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;query-processing-methodology&#34;&gt;Query Processing Methodology&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;Query Decomposition&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;input: Calculus query on global relations&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Normalization&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Analysis&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Simplification&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Restructing&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;output: Algebraic query&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Data Localization&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;input: Algebraic query on distributed relations&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Localization program&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Reduction based on the fragmentation strategy&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;PHF&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Select&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Because we have already divided the relations base on some rule. Only have to access the relations that have intersection with the query&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Join&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Distribute join over union&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(R1 U R2)⋈S  =&amp;gt; (R1⋈S) U (R2⋈S)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;by distribute 1 join to multiple join, we can eliminate some of them that have no intersection with the query&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VF&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;find useless intermiediate relations&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DHF&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;mix the PHF-Select and PHF-Join&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;example&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;query&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;eliminate by Selection&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;join over union&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;eliminate the empty intermediate relations&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Hybrid Fragmentation&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;remove empty relations by selection on HF&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;remove useless relations by projection on VF&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;distribute joins over unions to isolate and remove useless joins&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;output: Fragment query&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Distributed Query Optimization&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;input: Fragment query&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Find the best global schedule&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;query optimization process&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Search Space&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The set of equivalent alebra expressions&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Join Trees&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Linear join tree&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bushy join tree&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cost Model&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I/O cost + CPU cost + communication cost&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Search Algorithm&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;exhaustive search / heuristic algorithm&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;how to &amp;ldquo;move&amp;rdquo; in the search space&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Deterministic&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;start from base relations and build  plans by adding one relation at each step&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DP: BFS&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Greedy: DFS&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Randomized&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;trade optimization time for execution time&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;iterative improvement&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
